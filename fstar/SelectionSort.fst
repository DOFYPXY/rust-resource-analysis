(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [selection_sort] *)
module SelectionSort
open Primitives

#set-options "--z3rlimit 50 --fuel 1 --ifuel 1"

(** The state type used in the state-error monad *)
assume type state : Type0

(** [selection_sort::List] *)
type list_t (t : Type0) =
| ListCons : t -> list_t t -> list_t t
| ListNil : list_t t

(** [selection_sort::tick] *)
let tick_fwd : result unit = Return ()

(** [selection_sort::comp] *)
let comp_fwd (t : Type0) (x : t) (y : t) : result bool = Return false

(** [selection_sort::find_min] *)
let rec find_min_fwd (t : Type0) (l : list_t t) : result (list_t t) =
  begin match l with
  | ListCons x xs ->
    let* l0 = find_min_fwd t xs in
    begin match l0 with
    | ListCons y ys ->
      let* _ = tick_fwd in
      let* b = comp_fwd t x y in
      if b
      then let l1 = ListCons y ys in Return (ListCons x l1)
      else let l1 = ListCons x ys in Return (ListCons y l1)
    | ListNil -> let l1 = ListNil in Return (ListCons x l1)
    end
  | ListNil -> Return ListNil
  end

(** [selection_sort::sort] *)
let rec sort_fwd (t : Type0) (l : list_t t) : result (list_t t) =
  let* l0 = find_min_fwd t l in
  begin match l0 with
  | ListCons hd tl ->
    let* _ = tick_fwd in
    let* l1 = sort_fwd t tl in
    let l2 = l1 in
    Return (ListCons hd l2)
  | ListNil -> Return ListNil
  end

