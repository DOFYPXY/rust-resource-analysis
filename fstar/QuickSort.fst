(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [quick_sort] *)
module QuickSort
open Primitives

#set-options "--z3rlimit 50 --fuel 1 --ifuel 1"

(** The state type used in the state-error monad *)
assume type state : Type0

(** [quick_sort::List] *)
type list_t (t : Type0) =
| ListCons : t -> list_t t -> list_t t
| ListNil : list_t t

(** [quick_sort::tick] *)
let tick_fwd : result unit = Return ()

(** [quick_sort::comp] *)
let comp_fwd (t : Type0) (x : t) (y : t) : result bool = Return false

(** [quick_sort::append] *)
let rec append_fwd
  (t : Type0) (l1 : list_t t) (l2 : list_t t) : result (list_t t) =
  let* _ = tick_fwd in
  begin match l1 with
  | ListCons x xs ->
    let* l = append_fwd t xs l2 in let l0 = l in Return (ListCons x l0)
  | ListNil -> Return l2
  end

(** [quick_sort::partition] *)
let rec partition_fwd
  (t : Type0) (l : list_t t) (x : t) : result ((list_t t) & (list_t t)) =
  let* _ = tick_fwd in
  begin match l with
  | ListCons hd tl ->
    let* p = partition_fwd t tl x in
    let (cs, bs) = p in
    let* b = comp_fwd t x hd in
    if b
    then let l0 = bs in Return (cs, ListCons hd l0)
    else let l0 = cs in Return (ListCons hd l0, bs)
  | ListNil -> Return (ListNil, ListNil)
  end

(** [quick_sort::sort] *)
let rec sort_fwd (t : Type0) (l : list_t t) : result (list_t t) =
  let* _ = tick_fwd in
  begin match l with
  | ListCons x xs ->
    let* p = partition_fwd t xs x in
    let (ys, zs) = p in
    let* l0 = sort_fwd t ys in
    let* l1 = sort_fwd t zs in
    let l2 = l1 in
    append_fwd t l0 (ListCons x l2)
  | ListNil -> Return ListNil
  end

